Role:
You are a Senior Java Backend Engineer working on an existing enterprise Spring Boot application.
You are extending an already running WhatsApp + OpenAI integration.
Do NOT refactor unrelated code.

Objective:
Implement a short-term conversation memory system (OpenAI-style) using Redis,
allowing contextual responses while keeping memory limited, time-bound, and lightweight.

Functional Requirements:

1. Prompt Storage (Redis)
- Store only the last 20 user prompts per user.
- Use Redis as the backing store.
- Identify the user using message.getFrom().
- Redis key format:
  chat:short_term:{message.getFrom()}
- Example:
  chat:short_term: 923001234567
- Store each prompt as a plain string (no JSON, no role metadata).
- Set TTL to 15 minutes.
- TTL must be refreshed on every new prompt.
- Redis must automatically expire data after TTL.

2. Persistence Logic
Class: OfspHandler
Method: handleInbondMessage(...)

- Only when the user selects menu option "chat_agent":
  - Persist the user prompt to Redis.
  - Maintain FIFO behavior (remove oldest if size exceeds 20).
  - Use Redis List operations (RPUSH + LTRIM).
  - Do not write to Redis for any other menu option.

3. Conversation Retrieval & OpenAI Integration
Class: OfspHandler
Method: sendChatAgentMessage(...)

- Retrieve stored prompts from Redis using message.getFrom().
- Build conversation context in strict chronological order (oldest â†’ newest).
- Format context as:
  User: <message1>
  User: <message2>
  ...
  User: <currentMessage>
- Append the current user message at the end.
- Send the final combined prompt to:
  openAIService.getResponse(userMessageWithContext)

4. Failure Handling
- Redis failures must NOT crash the flow.
- If Redis is unavailable or throws any exception:
  - Log the error
  - Proceed by calling OpenAI with only the current user message
  - Do not propagate Redis exceptions

Technical Constraints:
- Follow Spring Boot best practices.
- Use Redis List (RPUSH + LTRIM).
- Avoid unnecessary synchronization (Redis operations are atomic).
- Ensure null safety.
- Keep implementation minimal and focused.

Output Expectations:
- Explain overall design approach.
- Show Redis key structure.
- Provide Java-level pseudo-code or sample methods.
- Clearly explain how short-term memory and TTL are achieved.

Non-Goals:
- No long-term memory
- No database persistence
- No embeddings or vector search
- No refactoring of unrelated code

Success Criteria:
- Contextual conversation support
- Automatic expiry after 15 minutes
- Lightweight, scalable, production-safe solution