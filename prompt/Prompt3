Role:
You are a Senior Java Backend Engineer working on an existing enterprise Spring Boot application.
You are extending an already running WhatsApp + OpenAI integration.
Do NOT refactor unrelated code.

Objective:
Implement a short-term conversation memory system (OpenAI-style) using Redis,
allowing contextual responses while keeping memory limited, time-bound, and lightweight.

Functional Requirements:

1. Prompt Storage (Redis)
- Store only the last 20 user prompts per user.
- Use Redis as the backing store.
- Identify the user using message.getFrom().
- Redis key format:
  chat:short_term:{message.getFrom()}
- Example:
  chat:short_term: 923001234567
- Store each prompt as a plain string (no JSON, no role metadata).
- Set TTL to 15 minutes.
- TTL must be refreshed on every new prompt.
- Redis must automatically expire data after TTL.

2. Persistence Logic
Class: OfspHandler
Method: handleInbondMessage(...)

- Only when the user selects menu option "chat_agent":
  - Persist the user prompt to Redis.
  - Maintain FIFO behavior (remove oldest if size exceeds 20).
  - Use Redis List operations (RPUSH + LTRIM).
  - Do not write to Redis for any other menu option.

3. Conversation Retrieval & OpenAI Integration
Class: OfspHandler
Method: sendChatAgentMessage(...)

- Retrieve stored prompts from Redis using message.getFrom().
- Build conversation context in strict chronological order (oldest → newest).
- Format context as:
  User: <message1>
  User: <message2>
  ...
  User: <currentMessage>
- Append the current user message at the end.
- Send the final combined prompt to:
  openAIService.getResponse(userMessageWithContext)

4. Failure Handling
- Redis failures must NOT crash the flow.
- If Redis is unavailable or throws any exception:
  - Log the error
  - Proceed by calling OpenAI with only the current user message
  - Do not propagate Redis exceptions

Technical Constraints:
- Follow Spring Boot best practices.
- Use Redis List (RPUSH + LTRIM).
- Avoid unnecessary synchronization (Redis operations are atomic).
- Ensure null safety.
- Keep implementation minimal and focused.

Output Expectations:
- Explain overall design approach.
- Show Redis key structure.
- Provide Java-level pseudo-code or sample methods.
- Clearly explain how short-term memory and TTL are achieved.

Non-Goals:
- No long-term memory
- No database persistence
- No embeddings or vector search
- No refactoring of unrelated code

Success Criteria:
- Contextual conversation support
- Automatic expiry after 15 minutes
- Lightweight, scalable, production-safe solution



==============================================================
Role:
You are a Senior Java Backend Engineer working on an existing enterprise Spring Boot application.
You are extending an already running WhatsApp + OpenAI integration.
Do NOT refactor unrelated code.

Objective

Create a separate, reusable method responsible for sending OpenAI responses to WhatsApp users.

Functional Requirements
1. OpenAI Response Sender Method
Class:
WhatsAppSendMessageService

Method:
sendOpenAiMessage(...)

Responsibilities:

This method is solely responsible for sending the OpenAI-generated response to the user via WhatsApp.
The WhatsApp message must include a footer with the text:
Reply E to end the chat.


The footer text MUST be read from application.properties.
Footer value should be injected using:
@Value, or a dedicated @ConfigurationProperties class.
No hardcoding of footer text anywhere in the codebase.

2. Usage from Chat Agent Flow
Class:
OfspHandler

Method:
sendChatAgentMessage(...)

Required Change:
Use:

WhatsAppSendMessageService.sendOpenAiMessage(...)
Do not modify OpenAI request logic.
Ensure the OpenAI response is passed cleanly to this method.

3. Configuration Requirement
application.properties

whatsapp.chat.footer=Reply *E* to end the chat.


==============================================================

Role: You are a Senior Java Backend Engineer working on an existing
enterprise Spring Boot application.

Context: The application already has a working WhatsApp + OpenAI
integration. You must extend existing behavior only and must NOT
refactor or change unrelated code.

Objective: Enhance the OpenAI request so that a prefix message is always
prepended to the user prompt.

Functional Requirements: 1. Fetch the prefix message from: - chatPrefix
field in the Client class 2. Prepend this prefix to the OpenAI request
message 3. Apply the change only in the specified method

Implementation Constraints: - Class to modify: OfspHandler - Method to
update: sendOpenAiMessage(…) - Do NOT: - Rename classes or methods -
Change method signatures - Refactor existing logic unrelated to this
requirement - Introduce new frameworks or architectural changes

Expected Behavior: - When sendOpenAiMessage(…) is invoked: - Retrieve
chatPrefix from the associated Client object - Prepend it to the OpenAI
prompt - Send the combined message to OpenAI - If chatPrefix is null or
empty: - Proceed with the original message unchanged

Output Required: - Provide only the updated Java code for the modified
method - Clearly highlight or comment the newly added lines - Assume all
required objects already exist and are accessible